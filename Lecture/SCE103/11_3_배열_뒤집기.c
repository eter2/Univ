// 재귀 함수를 사용하면 일부분의 문제를 해결하고 이를 반복하는 과정을 통해 전체 문제를 해결하는 방법을 적용할 수 있다. 이러한 기법을 분할정복 기법이라고 한다.

// 실습 내용
// N개의 원소를 가진 배열 A가 입력으로 주어진다. 이 배열의 모든 원소의 순서를 반대로 뒤집은 결과를 출력하시오. 단, 주어진 재귀 함수를 완성하여 구현하시오. 반복문을 사용하지 않는다.
//     L번째 원소부터 R번째 원소까지의 연속된 범위를 A[L : R]이라고 표기하자.
//     L번째 원소부터 R번째 원소의 순서를 모두 뒤집은 결과를 f(A[L:R])이라고 표기하자.
//     f(A[L:R])은 A의 L번째 원소(A[L])와 R번째 원소(A[R])의 자리를 바꾼 후, f(A[(L+1):(R-1)]) 범위를 뒤집은 결과와 같다.
// 예를 들어보자.
//     배열 A가 [ 5, 3, 7, 2, 9, 6 ] 와 같다고 하자.
//     이 배열은 세 부분  [ 5 ] , [ 3, 7, 2, 9 ] , [ 6 ] 으로 나눌 수 있다.
//     f( [ 5, 3, 7, 2, 9, 6]   )
//     = [6] + f([ 3 , 7, 2 , 9 ]) + [5]
//     = [6] + [9, 2, 7, 3] + [5]
//     = [ 6, 9, 2, 7, 3, 5 ]

// 입력 형식
// 첫 줄에는 배열 A의 원소의 수를 나타내는 10만 이하의 자연수 N이 주어진다.
// 이후 총 N줄에 걸쳐서 배열 A의 원소가 차례로 한 줄에 하나씩 주어진다. 모든 원소는 32비트 int형 범위에 포함된다.
//     1번째 원소
//     2번째 원소
//     ...
//     N번째 원소
// 순으로 주어진다.

// 출력 형식
// 배열 A의 모든 원소의 순서를 뒤집은 결과를 N줄에 걸쳐서 출력한다. 한 줄에 하나의 원소씩 차례로 출력한다.
//     1번째 원소
//     2번째 원소
//     ...
//     N번째 원소
// 순으로 출력한다.

// 입/출력 예시
// 예시 1
// 입력
// 5
// 1
// 2
// 3
// 4
// 5
// 출력
// 5
// 4
// 3
// 2
// 1
// 예시 2
// 입력
// 4
// 1
// 2
// 1
// 2
// 출력
// 2
// 1
// 2
// 1

#include <stdio.h>
#include <stdlib.h>

//두 포인터 a, b가 가리키는 변수의 값을 서로 바꾸어 주는 함수
// 사용 예 : 
//	int x = 5;
//	int y = 4;
//	swap(&x, &y); // x와 y의 값이 교환된다
void swap(int *a, int *b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}

//arr[left] ~ arr[right] 범위의 값들을 반대 순서로 뒤집어주는 함수
void reverse(int arr[], int left, int right, int arr2[])
{
	//종료조건 및 예외 처리 
	if (left > right)
	{
		return;
	}
	else if (left == right)
	{
		arr2[left] = arr[left];
		return;
	}

	arr2[right] = arr[left];
	arr2[left] = arr[right];

	//재귀 호출
	return reverse(arr, left + 1, right - 1, arr2);
}

int main()
{
	int n;	//배열의 원소의 수 
	int *arr;	//배열 포인터 

	//원소의 수를 입력받는다 
	scanf("%d", &n);

	//arr포인터에 동적 배열을 n칸 할당한다 
	arr = (int*)malloc(sizeof(int) * n);

	int *arr2;
	arr2 = (int*)malloc(sizeof(int) * n);

	//원소를 순서대로 입력받는다
	for (int i = 0; i < n; i++)
	{
		scanf("%d", &arr[i]);
	}

	//arr[0] ~ arr[n-1]의 원소들을 순서를 뒤집는다
	reverse(arr, 0, n - 1, arr2);

	//배열의 원소를 차례로 출력한다 
	for (int i = 0; i < n; i++)
	{
		printf("%d\n", arr2[i]);
	}

	//동적 할당을 해제한다
	free(arr);
	return 0;
}
