// 실습 내용
// 하나의 3차 함수 y=f(x)에 대한 정보가 입력으로 주어진다. 이 함수는 아래의 조건을 만족한다.
//     단 하나의 근을 가진다.
//     네 입력 값 a, b, c, d에 대하여 f(x) = a*x^3 + b*x^2 + c*x + d의 꼴을 가진다.
//     일대일 대응이며 증가함수다. x값이 증가하면 항상 y값이 증가함이 보장된다.
// 입력으로 f(x)의 네 계수 a, b, c, d가 주어질 때 해당 함수의 근이 존재하는 f(x) = 0이 되는 x값을 계산하는 프로그램을 작성하시오. 단, 정답은 항상 [-1e9, 1e9]범위 사이에 존재함이 보장된다.

// 입력 조건
// 네 계수 a, b, c, d가 차례로 공백으로 구분되어 주어진다.
//     네 계수는 모두 32비트 int형 정수다.
//     a는 항상 자연수다.

// 출력 조건
// f(x) = 0이 되는 근을 출력한다. 소수점 네 번째 자리에서 반올림하여 세 번째 자리까지 출력한다.

// 힌트
// 증가함수 혹은 감소함수 같은 일대일 대응 함수에서는 대소관계를 이용해 이분 탐색을 적용할 수 있다. 바이너리 서치를 이용해 실수해를 근사하는 알고리즘을 구현 해보자.
// 이분법을 많이 수행 할수록 근사값의 정밀도가 높아진다. 이 점에 유의하며 구현하자. 충분히 적용하지 않으면 근이 제대로 근사되지 않을 수 있다.
// 구글링 키워드 : Bisection Method Binary Search

// 입/출력 예시
// 예시 1
// 입력
// 1 -3 3 -2
// 출력
// 2.000
// 예시 2
// 입력
// 3 0 0 -18
// 출력
// 1.817
// 예시 3
// 입력
// 4 36 108 106
// 출력
// -2.206

#include <stdio.h>
#include <math.h>

int a, b, c, d;

double func(double x)
{
	return a * x * x * x + b * x * x + c * x + d;
}

int main()
{
	double left = -1e9;
	double right = 1e9;

	scanf("%d %d %d %d", &a, &b, &c, &d);

	float x = (left + right) / 2;

	while (fabs(left - right) > 0.00001)
	{
		if (func(left)*func(x) < 0)
		{
			right = x;
		}
		else
		{
			left = x;
		}

		x = (left + right) / 2;
	}

	printf("%.3f\n", x);

	return 0;
}